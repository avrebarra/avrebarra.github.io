{
    "version": "https://jsonfeed.org/version/1",
    "title": "Avré Barra",
    "home_page_url": "https://avrebarra.github.io//",
    "feed_url": "https://avrebarra.github.io//feed.json",
    "description": "A stash for short articles",
    "icon": "https://avrebarra.github.io//apple-touch-icon.png",
    "favicon": "https://avrebarra.github.io//favicon.ico",
    "expired": false,
    
    "author":  {
        "name": "Avre Barra",
        "url": "https://github.com/avrebarra",
        "avatar": null
    },
    
"items": [
    
        {
            "id": "https://avrebarra.github.io//2021/06/28/ddd-despicable-damned-design",
            "title": "DDD? Despicable Damned Design?",
            "summary": null,
            "content_text": "Added: June 28, 2021 21:50:08DDD means Domain Driven Design, we all knew this.DDD could also means Damn Disis Deeply-nestedDDD could also means Douchebag-coder Did DatDDD could also means Doh, Damn, DohDDD could also means Despicable Damned DesignIt might seems like I despise it, but really I don’t hate DDD. In fact I always try to ensure my code follows that.Then? I just think that some people took it wrongly (or maybe I understood it wrong?). Makes me hate it when people start debating about structuring this like this to follow DDD, Hexagonal, Clean Code, MVC only leaving a jumbled deeply nested codebase after that.From my honest perspective, DDD is an abstraction. That’s that. Not a filename, not a folder names, not a project structure. I mean if we structured our codes flat, doesn’t always mean we’re not DDD-ing. We can do DDD principles with three files, even one file.All abstraction are meant to help us explain and understand our code better. No you cannot say, “This project structured around DDD, just learn DDD concept here’s the link.” No jackshits, that’s irresponsibility (especially knowing how deep DDD topics are). Honestly, if we devised a project with DDD and it made us took longer time for us to explain to any decent newcomer until they can visualize and continue it, then I believe something is missing.I love DDD, and also MVC, three-tiers, two-tiers, OOP, Functional, Hexagonal, etc. Those are names of perspectives/telescopes/eyeglasses/loupes. They are tools to see our code from proven sides. Just how wasteful is it to limit a project to only one of them when you actually benefit from many on the same time?",
            "content_html": "<p>Added: June 28, 2021 21:50:08</p><p>DDD means Domain Driven Design, we all knew this.</p><p>DDD could also means Damn Disis Deeply-nested</p><p>DDD could also means Douchebag-coder Did Dat</p><p>DDD could also means Doh, Damn, Doh</p><p>DDD could also means Despicable Damned Design</p><p>It might seems like I despise it, but really I don’t hate DDD. In fact I always try to ensure my code follows that.</p><p>Then? I just think that some people took it wrongly (or maybe I understood it wrong?). Makes me hate it when people start debating about structuring this like this to follow DDD, Hexagonal, Clean Code, MVC only leaving a jumbled deeply nested codebase after that.</p><p>From my honest perspective, DDD is an abstraction. That’s that. Not a filename, not a folder names, not a project structure. I mean if we structured our codes flat, doesn’t always mean we’re not DDD-ing. We can do DDD principles with three files, even one file.</p><p>All abstraction are meant to help us explain and understand our code better. No you cannot say, “This project structured around DDD, just learn DDD concept here’s the link.” No jackshits, that’s irresponsibility (especially knowing how deep DDD topics are). Honestly, if we devised a project with DDD and it made us took longer time for us to explain to any decent newcomer until they can visualize and continue it, then I believe something is missing.</p><p>I love DDD, and also MVC, three-tiers, two-tiers, OOP, Functional, Hexagonal, etc. Those are names of perspectives/telescopes/eyeglasses/loupes. They are tools to see our code from proven sides. Just how wasteful is it to limit a project to only one of them when you actually benefit from many on the same time?</p>",
            "url": "https://avrebarra.github.io//2021/06/28/ddd-despicable-damned-design",
            
            
            
            "tags": ["golang","tech"],
            
            "date_published": "2021-06-28T00:00:00+00:00",
            "date_modified": "2021-06-28T00:00:00+00:00",
            
                "author":  {
                "name": "Avre Barra",
                "url": "https://github.com/avrebarra",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://avrebarra.github.io//2021/05/11/fabel-fabel-kecil",
            "title": "Fabel Fabel Kecil",
            "summary": null,
            "content_text": "Added: May 11, 2021 10:52 PMSeekor penyu menyisir pantai.Seekor ikan kembung lewat menyapa, “Kura-kura mau kemana?” “Aku penyu. Aku sedang mencari kacang.” Keduanya kembali melanjutkan tujuan masing-masing.Seekor camar lewat menyapa, “Kura-kura suka ganggang biru atau hijau?” “Aku penyu. Aku suka yang hijau.” Keduanya kembali melanjutkan tujuan masing-masing.Seekor keong lewat menyapa, “Kura-kura punya makanan?” “Aku penyu. Aku tidak punya makanan.” Keduanya kembali melanjutkan tujuan masing-masing.Tiba tiba seekor kelinci muncul, “Hati-hati aku tadi bertemu pemburu kura-kura.” “…” “Aku penyu. Aku bukan kura-kura.” Keduanya kembali melanjutkan tujuan masing-masing.Setelah berjalan lama, dari balik semak, pemburu kura-kura muncul, “Akhirnya menemukan kura-kura.” “Aku penyu. Aku bukan kura-kura.” “Tapi menurutku kamu juga kura-kura.” Pemburu kembali melanjutkan tugasnya. Kura-kura tidak bisa  melanjutkan tujuannya.Added: June 28, 2021 21:50:08Di satu sudut samudra, hidup sekumpulan ikan.Dari sekumpulan ikan itu, ada satu ikan yang serakah.Setiap ikan lain menemukan makanan, dia merebut. Setiap kali ikan lain menemukan makanan, dia merebut.Dengan semua makanan itu semakin hari dia tumbuh semakin besar dan ikan-ikan lain semakin kecil. Kini tidak ada yang bisa melawan dia lagi.Suatu malam nelayan datang ke atas permukaan itu dan menebar jalanya.Ikan-ikan terkejut karena tertangkap jala, tapi karena tubuh mereka sangat kurus, mereka bisa lari dari sela jala itu.Tinggallah satu ikan serakah di dalam jala itu. Dia tidak bisa lolos dengan tubuhnya yang terlalu besar.Di pagi hari, ikan-ikan melihat nelayan pulang bahagia dengan ikan besarnya.Mereka tidak bahagia karena teman mereka tertangkap.Tentunya mereka pun tidak sedih.",
            "content_html": "<p>Added: May 11, 2021 10:52 PM</p><p>Seekor penyu menyisir pantai.</p><p>Seekor ikan kembung lewat menyapa, “Kura-kura mau kemana?” “Aku penyu. Aku sedang mencari kacang.” Keduanya kembali melanjutkan tujuan masing-masing.</p><p>Seekor camar lewat menyapa, “Kura-kura suka ganggang biru atau hijau?” “Aku penyu. Aku suka yang hijau.” Keduanya kembali melanjutkan tujuan masing-masing.</p><p>Seekor keong lewat menyapa, “Kura-kura punya makanan?” “Aku penyu. Aku tidak punya makanan.” Keduanya kembali melanjutkan tujuan masing-masing.</p><p>Tiba tiba seekor kelinci muncul, “Hati-hati aku tadi bertemu pemburu kura-kura.” “…” “Aku penyu. Aku bukan kura-kura.” Keduanya kembali melanjutkan tujuan masing-masing.</p><p>Setelah berjalan lama, dari balik semak, pemburu kura-kura muncul, “Akhirnya menemukan kura-kura.” “Aku penyu. Aku bukan kura-kura.” “Tapi menurutku kamu juga kura-kura.” Pemburu kembali melanjutkan tugasnya. Kura-kura tidak bisa  melanjutkan tujuannya.</p><hr /><p>Added: June 28, 2021 21:50:08</p><p>Di satu sudut samudra, hidup sekumpulan ikan.</p><p>Dari sekumpulan ikan itu, ada satu ikan yang serakah.</p><p>Setiap ikan lain menemukan makanan, dia merebut. Setiap kali ikan lain menemukan makanan, dia merebut.</p><p>Dengan semua makanan itu semakin hari dia tumbuh semakin besar dan ikan-ikan lain semakin kecil. Kini tidak ada yang bisa melawan dia lagi.</p><p>Suatu malam nelayan datang ke atas permukaan itu dan menebar jalanya.</p><p>Ikan-ikan terkejut karena tertangkap jala, tapi karena tubuh mereka sangat kurus, mereka bisa lari dari sela jala itu.</p><p>Tinggallah satu ikan serakah di dalam jala itu. Dia tidak bisa lolos dengan tubuhnya yang terlalu besar.</p><p>Di pagi hari, ikan-ikan melihat nelayan pulang bahagia dengan ikan besarnya.</p><p>Mereka tidak bahagia karena teman mereka tertangkap.</p><p>Tentunya mereka pun tidak sedih.</p>",
            "url": "https://avrebarra.github.io//2021/05/11/fabel-fabel-kecil",
            
            
            
            "tags": ["shortstory","dongeng","fables"],
            
            "date_published": "2021-05-11T00:00:00+00:00",
            "date_modified": "2021-05-11T00:00:00+00:00",
            
                "author":  {
                "name": "Avre Barra",
                "url": "https://github.com/avrebarra",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://avrebarra.github.io//2021/01/11/defining-error-types-in-golang-modules",
            "title": "Defining Error Types in Golang Modules",
            "summary": null,
            "content_text": "Created: Jan 11, 2021 2:03 PM  TL;DR: Jump to Way #3 to see how we can use Golang errors.Is() to define error kinds/types.When I got spare times at work, I always love to experiment with Golang. Things felt fast, reliable, and simple. But sometimes there are things that took some time to think hard. One thing is: How I could specify error types so my other module can differentiate it?In Golang, we were taught to pass error around as variable. Neat concept. All bliss until some part of code need to know what kind of error that was?This is a case that will come up pretty often. Let’s suppose we had a module that have multiple reason of errors (e.g whether it is a DB failure, HTTP request drop, error from remote API, etc). Then we want to let other modules to know which kind of error returned, so the they can handle it differently depending on what kind of error it was. In Golang, what defines error type is basically anything with .Error() func that returns string. So, basically it’s just a string passed around. Then how do we identify it so we know what kind of error was that?In this post I’ve collected methods I’ve used over my months of trying Golang:  Enumerate errors by checking their messages  Enumerate error types using custom struct  Enumerate error types using errors.Is()Way #1: Comparing the message stringI talked this with friend, my friend used to suggest to just differentiate it using strings.Contains().What!? Yes, it doesn’t need a spider sense to know that’s a bit off. We can imagine all kind of development changes that could break this, like: adjustment of message, error with similar messages, mistypes, and many thing regarding how string consistency is a mortal inside our codebase.But because it actually works, and I’m trying to make this post follow to rule of third :) here it is:package thepkgimport (\t\"fmt\"\t\"math/rand\")// SomethingFaulty is function that return multiple kind of errorfunc SomethingFaulty() error {\tvar randnum int = int(rand.Float32() * 10)\tswitch randnum {\tcase 1:\t\treturn fmt.Errorf(\"database error: imagine it\")\tcase 2:\t\treturn fmt.Errorf(\"http call error: when the connection broke\")\tcase 3:\t\treturn fmt.Errorf(\"remote api error: when the req ok but they says no\")\tdefault:\t\treturn fmt.Errorf(\"unexpected error: kinda don't know what is it\")\t}}package mainimport (\t\"fmt\"\t\"strings\"\t\"github.com/me/experror/thepkg\")func main() {\t// perform the faulty function\terr := thepkg.SomethingFaulty()\tif err != nil {\t\terrmsg := err.Error()\t\tswitch true {\t\tcase strings.Contains(errmsg, \"database error\"):\t\t\tfmt.Println(\"aww: man database error\")\t\t\treturn\t\tcase strings.Contains(errmsg, \"http call error\"):\t\t\tfmt.Println(\"ugh: the traffic again\")\t\t\treturn\t\tcase strings.Contains(errmsg, \"remote api error\"):\t\t\tfmt.Println(\"perhaps we dont knock nice enough\")\t\t\treturn\t\tdefault:\t\t\tfmt.Println(\"hmm: i dont quite recognize this\")\t\t\treturn\t\t}\t}\tfmt.Println(\"all is good in this pandemic: this never happened (the code path)\")}Pros: naive approach that pretty small, simple, and intuitiveCons: many thing could unintendedly break this, like: other error (from other module) that accidentally have similar messages, and generally its always a bad idea to rely to thing that’s not supposed to be the contract.Way #2: Introducing custom error structWe just talked previously that in Golang, what defines error type is basically anything with .Error() func that returns string. So, naturally there must be an option about custom error: Custom struct with Error() function.We can do it by creating these custom struct. To differentiate it, we could parse it back to error struct using coercion like this:package thepkgimport (\t\"math/rand\")// Module's error codesconst (\tErrCodeDatabaseFailure    = \"X01\"\tErrCodeHTTPRequestFailure = \"X02\"\tErrCodeAPIError           = \"X03\"\tErrCodeUnexpectedFailure  = \"X99\")// Error is this module's error objecttype Error struct {\tCode    string\tMessage string}func (e Error) Error() string {\treturn e.Message}// SomethingFaulty is function that return multiple kind of errorfunc SomethingFaulty() error {\tvar randnum int = int(rand.Float32() * 10)\tswitch randnum {\tcase 1:\t\treturn Error{Code: ErrCodeDatabaseFailure, Message: \"database error: imagine it\"}\tcase 2:\t\treturn Error{Code: ErrCodeHTTPRequestFailure, Message: \"http call error: when the connection broke\"}\tcase 3:\t\treturn Error{Code: ErrCodeAPIError, Message: \"remote api error: when the req ok but they says no\"}\tdefault:\t\treturn Error{Code: ErrCodeUnexpectedFailure, Message: \"unexpected error: kinda don't know what is it\"}\t}}package mainimport (\t\"fmt\"\t\"github.com/me/experror/thepkg\")func main() {\t// perform the faulty function\terr := thepkg.SomethingFaulty()\tif e, ok := err.(thepkg.Error); ok {\t\terr = nil // the error is fully handled here\t\tswitch e.Code {\t\tcase thepkg.ErrCodeDatabaseFailure:\t\t\tfmt.Println(\"aww man database error\")\t\t\treturn\t\tcase thepkg.ErrCodeHTTPRequestFailure:\t\t\tfmt.Println(\"ugh the traffic again\")\t\t\treturn\t\tcase thepkg.ErrCodeAPIError:\t\t\tfmt.Println(\"perhaps we dont knock nice enough\")\t\t\treturn\t\tcase thepkg.ErrCodeUnexpectedFailure:\t\t\tfmt.Println(\"whoa: unexpected things happened\")\t\t\treturn\t\tdefault:\t\t\tfmt.Println(\"wait: unregistered code!\")\t\t\treturn\t\t}\t}\tif err != nil {\t\tfmt.Println(\"hmm.. i dont quite recognize this\")\t\treturn\t}\tfmt.Println(\"all is good in this pandemic: this never happened (the code path)\")}Pros: very useful to add additional information/identity to error, good strict contract for error type,Cons: bigger code footprint, and additional struct to add everytime we want to add error types to modules.Way #3: Leveraging the errors.Is()The previous way will work fine. But I still have one other, this last one is my favourite up until now.It is to leverage the errors.Is() module introduced in Go v1.13. This is by far my favourite because how clean and simple it is.package thepkgimport (\t\"fmt\"\t\"math/rand\")// Module's errorsvar (\tErrDatabaseFailure    = fmt.Errorf(\"database error: imagine it\")\tErrHTTPRequestFailure = fmt.Errorf(\"http call error: when the connection broke\")\tErrAPIError           = fmt.Errorf(\"remote api error: when the req ok but they says no\")\tErrUnexpectedFailure  = fmt.Errorf(\"unexpected error: kinda don't know what is it\"))// SomethingFaulty is function that return multiple kind of errorfunc SomethingFaulty() error {\tvar randnum int = int(rand.Float32() * 10)\tswitch randnum {\tcase 1:\t\treturn ErrDatabaseFailure\tcase 2:\t\treturn ErrHTTPRequestFailure\tcase 3:\t\treturn ErrAPIError\tdefault:\t\treturn ErrUnexpectedFailure\t}}package mainimport (\t\"errors\"\t\"fmt\"\t\"github.com/me/experror/thepkg\")func main() {\t// perform the faulty function\terr := thepkg.SomethingFaulty()\tif err != nil {\t\tswitch true {\t\tcase errors.Is(err, thepkg.ErrDatabaseFailure):\t\t\tfmt.Println(\"aww man database error\")\t\t\treturn\t\tcase errors.Is(err, thepkg.ErrHTTPRequestFailure):\t\t\tfmt.Println(\"ugh the traffic again\")\t\t\treturn\t\tcase errors.Is(err, thepkg.ErrAPIError):\t\t\tfmt.Println(\"perhaps we dont knock nice enough\")\t\t\treturn\t\tcase errors.Is(err, thepkg.ErrUnexpectedFailure):\t\t\tfmt.Println(\"whoa: unexpected things happened\")\t\t\treturn\t\tdefault:\t\t\tfmt.Println(\"hmm.. i dont quite recognize this\")\t\t\treturn\t\t}\t}\tfmt.Println(\"all is good in this pandemic: this never happened (the code path)\")}Pros: small code footprint, intuitive, not much to set up, enumeration got good support by Golang language server, message adjustment wont break things.Cons: usage of var instead of const, no additional error info/identities except messageThose three ways are the ones I’ve tried. By far, I’ll always use errors.Is(). It’s what I usually use and so far I like the simplicity and small code footprints, and it fits my use-cases most of the time. I’ve never really dig the performance side of these method on e.g very big error list (i don’t know if i’ll ever made that much error kinds in one package)But for anybody that need to add some info to their error (e.g error code, error name, stacks, etc) I’ll advise to use custom error struct. We can even combine the custom struct with errors.As() (i’ll probably write another post for that one). Unless needing those custom things, so far I think we could be pretty satisfied by how errors.Is() could offer instant help on defining error types.Because as always, neat and simple it is where we’ll go~!",
            "content_html": "<p>Created: Jan 11, 2021 2:03 PM</p><blockquote>  <p>TL;DR: Jump to Way #3 to see how we can use Golang <code>errors.Is()</code> to define error kinds/types.</p></blockquote><p>When I got spare times at work, I always love to experiment with Golang. Things felt fast, reliable, and simple. But sometimes there are things that took some time to think hard. One thing is: <strong>How I could specify error types so my other module can differentiate it?</strong></p><p>In Golang, we were taught to pass error around as variable. Neat concept. All bliss until some part of code need to know what kind of error that was?</p><p>This is a case that will come up pretty often. Let’s suppose we had a module that have multiple reason of errors (e.g whether it is a DB failure, HTTP request drop, error from remote API, etc). Then we want to let other modules to know which kind of error returned, so the they can handle it differently depending on what kind of error it was. In Golang, what defines <code>error</code> type is basically anything with <code>.Error()</code> func that returns string. So, basically it’s just a string passed around. <strong>Then how do we identify it so we know what kind of error was that?</strong></p><p>In this post I’ve collected methods I’ve used over my months of trying Golang:</p><ul>  <li>Enumerate errors by checking their messages</li>  <li>Enumerate error types using custom struct</li>  <li>Enumerate error types using errors.Is()</li></ul><h2 id=\"way-1-comparing-the-message-string\">Way #1: Comparing the message string</h2><p>I talked this with friend, my friend used to suggest to just differentiate it using <code>strings.Contains()</code>.</p><p>What!? Yes, it doesn’t need a spider sense to know that’s a bit off. We can imagine all kind of development changes that could break this, like: adjustment of message, error with similar messages, mistypes, and many thing regarding how string consistency is a mortal inside our codebase.</p><p>But because it actually works, and I’m trying to make this post follow to rule of third :) here it is:</p><pre><code class=\"language-go\">package thepkgimport (\t\"fmt\"\t\"math/rand\")// SomethingFaulty is function that return multiple kind of errorfunc SomethingFaulty() error {\tvar randnum int = int(rand.Float32() * 10)\tswitch randnum {\tcase 1:\t\treturn fmt.Errorf(\"database error: imagine it\")\tcase 2:\t\treturn fmt.Errorf(\"http call error: when the connection broke\")\tcase 3:\t\treturn fmt.Errorf(\"remote api error: when the req ok but they says no\")\tdefault:\t\treturn fmt.Errorf(\"unexpected error: kinda don't know what is it\")\t}}</code></pre><pre><code class=\"language-go\">package mainimport (\t\"fmt\"\t\"strings\"\t\"github.com/me/experror/thepkg\")func main() {\t// perform the faulty function\terr := thepkg.SomethingFaulty()\tif err != nil {\t\terrmsg := err.Error()\t\tswitch true {\t\tcase strings.Contains(errmsg, \"database error\"):\t\t\tfmt.Println(\"aww: man database error\")\t\t\treturn\t\tcase strings.Contains(errmsg, \"http call error\"):\t\t\tfmt.Println(\"ugh: the traffic again\")\t\t\treturn\t\tcase strings.Contains(errmsg, \"remote api error\"):\t\t\tfmt.Println(\"perhaps we dont knock nice enough\")\t\t\treturn\t\tdefault:\t\t\tfmt.Println(\"hmm: i dont quite recognize this\")\t\t\treturn\t\t}\t}\tfmt.Println(\"all is good in this pandemic: this never happened (the code path)\")}</code></pre><hr /><p><em>Pros: naive approach that pretty small, simple, and intuitive</em></p><p><em>Cons: many thing could unintendedly break this, like: other error (from other module) that accidentally have similar messages, and generally its always a bad idea to rely to thing that’s not supposed to be the contract.</em></p><h2 id=\"way-2-introducing-custom-error-struct\">Way #2: Introducing custom error struct</h2><p>We just talked previously that in Golang, what defines <code>error</code> type is basically anything with <code>.Error()</code> func that returns string. So, naturally there must be an option about custom error: Custom struct with <code>Error()</code> function.</p><p>We can do it by creating these custom struct. To differentiate it, we could parse it back to error struct using coercion like this:</p><pre><code class=\"language-go\">package thepkgimport (\t\"math/rand\")// Module's error codesconst (\tErrCodeDatabaseFailure    = \"X01\"\tErrCodeHTTPRequestFailure = \"X02\"\tErrCodeAPIError           = \"X03\"\tErrCodeUnexpectedFailure  = \"X99\")// Error is this module's error objecttype Error struct {\tCode    string\tMessage string}func (e Error) Error() string {\treturn e.Message}// SomethingFaulty is function that return multiple kind of errorfunc SomethingFaulty() error {\tvar randnum int = int(rand.Float32() * 10)\tswitch randnum {\tcase 1:\t\treturn Error{Code: ErrCodeDatabaseFailure, Message: \"database error: imagine it\"}\tcase 2:\t\treturn Error{Code: ErrCodeHTTPRequestFailure, Message: \"http call error: when the connection broke\"}\tcase 3:\t\treturn Error{Code: ErrCodeAPIError, Message: \"remote api error: when the req ok but they says no\"}\tdefault:\t\treturn Error{Code: ErrCodeUnexpectedFailure, Message: \"unexpected error: kinda don't know what is it\"}\t}}</code></pre><pre><code class=\"language-go\">package mainimport (\t\"fmt\"\t\"github.com/me/experror/thepkg\")func main() {\t// perform the faulty function\terr := thepkg.SomethingFaulty()\tif e, ok := err.(thepkg.Error); ok {\t\terr = nil // the error is fully handled here\t\tswitch e.Code {\t\tcase thepkg.ErrCodeDatabaseFailure:\t\t\tfmt.Println(\"aww man database error\")\t\t\treturn\t\tcase thepkg.ErrCodeHTTPRequestFailure:\t\t\tfmt.Println(\"ugh the traffic again\")\t\t\treturn\t\tcase thepkg.ErrCodeAPIError:\t\t\tfmt.Println(\"perhaps we dont knock nice enough\")\t\t\treturn\t\tcase thepkg.ErrCodeUnexpectedFailure:\t\t\tfmt.Println(\"whoa: unexpected things happened\")\t\t\treturn\t\tdefault:\t\t\tfmt.Println(\"wait: unregistered code!\")\t\t\treturn\t\t}\t}\tif err != nil {\t\tfmt.Println(\"hmm.. i dont quite recognize this\")\t\treturn\t}\tfmt.Println(\"all is good in this pandemic: this never happened (the code path)\")}</code></pre><p><em>Pros: very useful to add additional information/identity to error, good strict contract for error type,</em></p><p><em>Cons: bigger code footprint, and additional struct to add everytime we want to add error types to modules.</em></p><h2 id=\"way-3-leveraging-the-errorsis\">Way #3: Leveraging the errors.Is()</h2><p>The previous way will work fine. But I still have one other, this last one is my favourite up until now.</p><p>It is to leverage the errors.Is() module introduced in Go v1.13. This is by far my favourite because how clean and simple it is.</p><pre><code class=\"language-go\">package thepkgimport (\t\"fmt\"\t\"math/rand\")// Module's errorsvar (\tErrDatabaseFailure    = fmt.Errorf(\"database error: imagine it\")\tErrHTTPRequestFailure = fmt.Errorf(\"http call error: when the connection broke\")\tErrAPIError           = fmt.Errorf(\"remote api error: when the req ok but they says no\")\tErrUnexpectedFailure  = fmt.Errorf(\"unexpected error: kinda don't know what is it\"))// SomethingFaulty is function that return multiple kind of errorfunc SomethingFaulty() error {\tvar randnum int = int(rand.Float32() * 10)\tswitch randnum {\tcase 1:\t\treturn ErrDatabaseFailure\tcase 2:\t\treturn ErrHTTPRequestFailure\tcase 3:\t\treturn ErrAPIError\tdefault:\t\treturn ErrUnexpectedFailure\t}}</code></pre><pre><code class=\"language-go\">package mainimport (\t\"errors\"\t\"fmt\"\t\"github.com/me/experror/thepkg\")func main() {\t// perform the faulty function\terr := thepkg.SomethingFaulty()\tif err != nil {\t\tswitch true {\t\tcase errors.Is(err, thepkg.ErrDatabaseFailure):\t\t\tfmt.Println(\"aww man database error\")\t\t\treturn\t\tcase errors.Is(err, thepkg.ErrHTTPRequestFailure):\t\t\tfmt.Println(\"ugh the traffic again\")\t\t\treturn\t\tcase errors.Is(err, thepkg.ErrAPIError):\t\t\tfmt.Println(\"perhaps we dont knock nice enough\")\t\t\treturn\t\tcase errors.Is(err, thepkg.ErrUnexpectedFailure):\t\t\tfmt.Println(\"whoa: unexpected things happened\")\t\t\treturn\t\tdefault:\t\t\tfmt.Println(\"hmm.. i dont quite recognize this\")\t\t\treturn\t\t}\t}\tfmt.Println(\"all is good in this pandemic: this never happened (the code path)\")}</code></pre><p><em>Pros: small code footprint, intuitive, not much to set up, enumeration got good support by Golang language server, message adjustment wont break things.</em></p><p><em>Cons: usage of var instead of const, no additional error info/identities except message</em></p><hr /><p>Those three ways are the ones I’ve tried. By far, I’ll always use <code>errors.Is()</code>. It’s what I usually use and so far I like the simplicity and small code footprints, and it fits my use-cases most of the time. I’ve never really dig the performance side of these method on e.g very big error list (i don’t know if i’ll ever made that much error kinds in one package)</p><p>But for anybody that need to add some info to their error (e.g error code, error name, stacks, etc) I’ll advise to use custom error struct. We can even combine the custom struct with <code>errors.As()</code> (i’ll probably write another post for that one). Unless needing those custom things, so far I think we could be pretty satisfied by how <code>errors.Is()</code> could offer instant help on defining error types.</p><p>Because as always, neat and simple it is where we’ll go~!</p>",
            "url": "https://avrebarra.github.io//2021/01/11/defining-error-types-in-golang-modules",
            
            
            
            "tags": ["golang","tech"],
            
            "date_published": "2021-01-11T00:00:00+00:00",
            "date_modified": "2021-01-11T00:00:00+00:00",
            
                "author":  {
                "name": "Avre Barra",
                "url": "https://github.com/avrebarra",
                "avatar": null
                }
                
            
        }
    
    ]
}